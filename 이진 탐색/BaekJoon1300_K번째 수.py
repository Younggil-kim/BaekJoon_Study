#문제 해석

#크기가 N*N인 배열 A의 값은 i*j이다.
#이때 이 수를 전부 일차원 배열에 넣고 정렬시킨 후
# B[k]의 값을 구하라

#10만 * 10만이기 때문에 이중 for문으로 돌리면 시간초과가 난다
# 따라서, 일종의 규칙성을 발견해야 한다.
# mid값을 먼저 잡아주고, 그 이하의 개수를 구하는데,
# 이 값은 전체 행에서, mid/i 값과 N 값 중 작은 값을 택해서 더해주면 된다.
# 배열 B의 인덱스를 돌면서, 개수를 찾아야함
# 처음에는 (1 + k) //2 가 mid가 됨
# 따라서 N이 3이고 K가 7인경우 mid 는 4이므로
# 4/1 4/2 4/3
# 3 + 2 + 1 => cnt ==6.
# 세어보니 4보다 작거나 같은 개수는 6개야
# 7번째 인덱스를 찾아야해
# 그러니까 개수가 딸리거든, 그러면 mid값을 높여줘야해
# start = mid + 1로 올려주면 >> start == 5 , end == 7
# 따라서, mid = 6
# 6/1 6/2 6/3 각각과 3의 최소값을 더해주면
# >>> cnt = 3 + 3 + 2 >> 8
# 이 말의 뜻은, 6보다 작거나 같은 개수는 8개란 소리야
# 이렇게 되니까 7보다 크단말이지 그래서 mid를 낮출거야
# end = mid -1 로 낮춰주면, >> start = 5, end = 5
# 마지막 케이스가 될거야.
# 자, 5/1 5/2 5/3 과 3의 최소값을 더해주면
# 3 + 2 + 1 >> cnt == 6이야.
# 우리가 찾고있는것 7인데, 마지막케이스고,
# mid는 5인데, 5보다 작거나 같은 케이스의 개수는 6개래,
# 이 말은 지금, 5는 없다는 소리야, 4는 케이스를 돌렸으니까.
# 그러니까 마지막 최적의 해인, 6의 값이 답이 되는거야.
# 딱 맞아떨어지는 경우가 아닌거지

N = int(input())
K = int(input())

start = 1#인덱스 최소
end = K#인덱스 최대


result = 0
while start <= end:
    cnt = 0
    mid = (start + end)//2
    for i in range(1,N+1):
        cnt = cnt + min(mid//i, N)
    if cnt < K:#세었는데 덜나왔으면
        start = mid + 1 # 값을 올려줘야지
    else:#세었는데 많이 나왔거나 같으면
        # 값을 낮춰줘야해
        result = mid
        end = mid -1

print(result)

